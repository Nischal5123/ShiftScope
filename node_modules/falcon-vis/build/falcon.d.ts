import { View0D, View1D, ViewSet, View1DState, View0DState } from "./views";
import type { Dimension } from "./dimension";
import type { FalconDB, FalconIndex, Filters } from "./db/db";
import type { OnChange } from "./views/viewAbstract";
export declare class FalconVis {
    db: FalconDB;
    views: ViewSet;
    filters: Filters;
    index: FalconIndex;
    /**
     * Takes a data and creates the main driver of the Falcon library
     *
     * Here, you can then create new views (view0D or view1D) and directly interact with
     * those
     */
    constructor(db: FalconDB);
    /**
     * Creates a 0D view that counts the number of entries
     * if this is called when there is already an active view, it will just compute this passive index
     *
     * @returns the view
     */
    view0D(onChange?: OnChange<View0DState>): Promise<View0D>;
    /**
     * Creates a 1D view and links with the other views under this falcon object
     *
     * @returns the 1D view you can directly filter with .select()
     */
    view1D(dimension: Dimension, onChange?: OnChange<View1DState>): Promise<View1D>;
    /**
     * creates an iterator over the filtered entries located at the offset and with a specified length
     * for example, if we have 100 filtered entries, I can position myself halfway (offset = 50) and if I want
     * just 10 entries I would use length = 10
     *
     * @param offset the offset to start the iteration from (within filtered)
     * @param length the number of entries to return
     * @returns iterator over the filtered entries basically a list of objects
     */
    entries({ offset, length }?: {
        offset?: number | undefined;
        length?: number | undefined;
    }): Promise<Iterable<import("./iterator").Row | null>>;
    /**
     * Fetches the initial counts for all the views
     * This does not involve fetching the falcon index
     */
    all(): Promise<void>;
    link(): Promise<void>;
    /**
     * @returns the filters and excludes the active view dimension's filters
     */
    get passiveFilters(): Filters;
    otherFilters(view: View1D): Filters;
    /**
     * verifies if we can continue to do stuff on the data
     * throws an error if the data does not exist
     */
    assertDataExists(...dimensions: Dimension[]): Promise<void>;
}

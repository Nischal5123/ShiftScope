import { scaleLinear } from "d3";
import { bin as vegaBin } from "vega-statistics";
import { scaleTime } from "d3";
/**
 * UTILITY FUNCTIONS
 * -----------------
 */
/**
 * Get the number of bins for a bin configuration.
 */
export function numBinsCategorical(range) {
    return range.length;
}
/**
 * Takes the categorical names and maps them to indices
 * @returns function that returns bin index
 */
export function binNumberFunctionCategorical(range) {
    const binMapper = new Map(range.map((item, index) => [item, index]));
    return (item) => binMapper.get(item);
}
/**
 * Get the number of bins for a bin configuration.
 */
export function numBinsContinuous({ start, step, stop }) {
    return (stop - start) / step;
}
export function binContinuous(maxbins, extent, exact = false) {
    // will do exactly max bins
    if (exact) {
        return binRegularIntervals(maxbins, extent);
    }
    // might do bins less than maxbins, but will do it more nicely intervals
    return vegaBin({ maxbins, extent });
}
function binRegularIntervals(maxbins, extent) {
    const step = (extent[1] - extent[0]) / maxbins;
    const start = extent[0];
    const stop = extent[extent.length - 1];
    console.log(step, start, stop);
    return {
        start,
        stop,
        step: step,
    };
}
export function binTime(maxbins, extent, exact = false) {
    console.log("hit");
    if (exact) {
        return binRegularIntervals(maxbins, extent);
    }
    const ts = scaleTime().domain(extent);
    const ticks = ts.ticks(maxbins);
    const start = ticks[0].getTime();
    const stop = ticks[ticks.length - 1].getTime();
    const step = (stop - start) / ticks.length;
    // not that this is not accurate but the best we can do if we require regular intervals
    return {
        start,
        stop,
        step: step,
    };
}
/**
 * This function requires dimension.bins to exist
 *
 * if the exactNumberOfBins is true, will force a regular interval
 * if not, will try to make the bins as nice as possible, but maybe different number of bins than requested
 */
export function createBinConfigContinuous(dimension, extent, exactNumberOfBins = false) {
    const binningFunc = dimension.time ? binTime : binContinuous;
    return binningFunc(dimension.bins, extent, exactNumberOfBins);
}
export function binStartBinEndArray(binConfig) {
    let bins = [];
    let curStart = binConfig.start;
    let curEnd = curStart + binConfig.step;
    while (curEnd <= binConfig.stop) {
        bins.push({ binStart: curStart, binEnd: curEnd });
        curStart = curEnd;
        curEnd += binConfig.step;
    }
    return bins;
}
export function conciseBinsContinuous(binConfig) {
    const n = numBinsContinuous(binConfig);
    const bins = new Float32Array(n);
    let curStart = binConfig.start;
    for (let i = 0; i < n; i++) {
        bins[i] = curStart;
        curStart += binConfig.step;
    }
    return bins;
}
/**
 * returns a function to scales to pixel resolution to
 * the floor integer pixel
 */
export function brushToPixelSpace(extent, resolution) {
    const toPixelsAndFloor = scaleFilterToResolution(extent, resolution);
    return (brush) => {
        return [
            toPixelsAndFloor(brush[0]),
            toPixelsAndFloor(brush[1]),
        ];
    };
}
/**
 * returns a function to scales to pixel resolution to
 * the floor integer pixel
 */
export function scaleFilterToResolution(extent, resolution, nearestPixelInt = Math.floor) {
    const pixelSpace = [1, resolution];
    const valueSpace = extent;
    const toPixels = scaleLinear().domain(valueSpace).range(pixelSpace);
    toPixels.clamp(true);
    return (x) => {
        const pixels = toPixels(x);
        return nearestPixelInt(pixels);
    };
}
export function excludeMap(map, ...exclude) {
    return new Map(Array.from(map.entries()).filter(([key, _]) => !exclude.includes(key)));
}
/**
 * Returns a function that returns the bin for a value.
 */
export function binNumberFunctionContinuous({ start, step, stop }) {
    /**
     * this used to be (v: number) => Math.floor((v - start) / step
     * using floor seems to map to a non-existent bin sometimes
     *
     * for example when the v=stop
     * suppose we have start = 0, step = 20, stop = 100
     * this should be 5 bins in total, each bin corresponding to 0, 1, 2, 3, or 4. (5 bins in total)
     * however when v=100 (aka the stop)
     * Math.floor(100-0 / 20) = 5. ???? 5 should not be an index that is a non-existent bin
     *
     * Math.ceil(100-0 / 20) - 1 = 4 is correct
     * frick but when its 0, the whole things goes to -1
     * so we need to clamp it to 0
     */
    const numBins = numBinsContinuous({ start, step, stop });
    const lastBinIndex = numBins - 1;
    return (v) => {
        const binIndexMapping = Math.floor((v - start) / step);
        if (binIndexMapping >= numBins) {
            return lastBinIndex;
        }
        return binIndexMapping;
    };
}
/**
 * Creates a string equivalent to binNumberFunctionContinuous operation in SQL
 */
export function binNumberFunctionContinuousSQL(field, { start, step, stop }, castString = (x) => `${x}`, caseVersion = true) {
    const numBins = numBinsContinuous({ start, step, stop });
    const binIndexMapping = `FLOOR((${field} - ${castString(start)}) / ${castString(step)})`;
    const lastBinIndex = castString(numBins - 1);
    // some sql versions don't like least, but do like case
    if (caseVersion) {
        const caseClamp = `CASE WHEN ${binIndexMapping} >= ${lastBinIndex} THEN ${lastBinIndex} ELSE ${binIndexMapping} END`;
        return `cast(${caseClamp} as int)`;
    }
    const leastClamp = `LEAST(${lastBinIndex}, ${binIndexMapping})`;
    return `cast(${leastClamp} as int)`;
}
/**
 * Returns a function that returns the bin for a pixel. Starts one pixel before so that the brush contains the data.
 */
export function binNumberFunctionPixels({ start, stop }, pixel) {
    const step = stepSize({ start, stop }, pixel);
    return binNumberFunctionContinuous({ start, step, stop });
}
export function stepSize({ start, stop }, bins) {
    return (stop - start) / bins;
}
export function compactQuery(str) {
    return str.replace(/\s+/g, " ").trim();
}
//# sourceMappingURL=util.js.map
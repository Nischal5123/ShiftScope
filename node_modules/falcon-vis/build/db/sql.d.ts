import { FalconDB, Filters, AsyncIndex } from "./db";
import { Dimension, ContinuousRange, CategoricalRange, ContinuousDimension } from "../dimension";
import { FalconArray } from "../falconArray";
import { Row } from "../iterator";
import { View1D } from "../views";
import type { BinNumberFunction } from "../util";
import type { View } from "../views";
export type SQLNameMap = Map<string, string>;
export type SQLQuery = string;
export type PartialSQLQuery = string;
export type SQLQueryResult = Iterable<Row>;
export interface SQLBin {
    select: PartialSQLQuery;
    where: PartialSQLQuery;
}
export type SQLFilters = Map<Dimension, PartialSQLQuery>;
export declare abstract class SQLDB implements FalconDB {
    table: string;
    nameMap: SQLNameMap | undefined;
    constructor(table: string, nameMap?: SQLNameMap);
    protected castBins(input: number): string;
    /**
     * if the column is a time/date column, there may be some modifying
     * for example, in duckdb we have to do this bs epoch(name)*1000 to convert the date into milliseconds UTC
     */
    protected castTime(name: string): string;
    /**
     * intermediary function incase we mapped the names to something else
     * change this if you for example have issues with time dimensions
     *
     * @returns mapped string name defined from constructor
     */
    protected getName(dimension: Dimension): string;
    /**
     * After extending SQLDB, all you implement is the query!
     * This should take in a string SQL query and return the results
     *
     * @note Check out duckdb.ts or mapd.ts for examples.
     */
    protected abstract query(q: SQLQuery): SQLQueryResult | Promise<SQLQueryResult>;
    dimensionExists(dimension: Dimension): Promise<boolean>;
    tableExists(): Promise<boolean>;
    entries(offset?: number, length?: number, filters?: Filters): Promise<SQLQueryResult>;
    /**
     * compute the best number of bins for a histogram
     * given the data
     *
     * @resource [plot](https://github.com/observablehq/plot/blob/97924e7682e49d35a34da794ca98bf0c7e8a3c28/src/transforms/bin.js#L320)
     * @resource [lord and savior](https://twitter.com/mbostock/status/1429281697854464002)
     * @resource [numpy](https://numpy.org/doc/stable/reference/generated/numpy.histogram_bin_edges.html)
     */
    estimateNumBins(dimension: ContinuousDimension, maxThreshold?: number, noKnowledgeEstimate?: number): Promise<number>;
    length(filters?: Filters): Promise<any>;
    range(dimension: Dimension): Promise<ContinuousRange | CategoricalRange[]>;
    histogramView1D(view: View1D, filters?: Filters): Promise<{
        filter: FalconArray;
        noFilter: FalconArray;
    }>;
    falconIndexView1D(activeView: View1D, passiveViews: View[], filters: Filters): AsyncIndex;
    cubeSlice1DCategorical(view: View, sqlFilters: SQLFilters, binActive: SQLBin, binActiveIndexMap: BinNumberFunction, binCountActive: number): Promise<{
        noFilter: FalconArray;
        filter: FalconArray;
    }>;
    /**
     * Takes a view and computes the falcon cube for that passive view
     * more details in the [paper](https://idl.cs.washington.edu/files/2019-Falcon-CHI.pdf)
     *
     * @note Only works for 0D and 1D continuous views at the moment
     * @returns a cube as FalconArray for the passive view
     */
    cubeSlice1DContinuous(view: View, sqlFilters: SQLFilters, binActive: SQLBin, numPixels: number): Promise<{
        filter: FalconArray;
        noFilter: FalconArray;
    }>;
    /**
     * Easily extract the "as" values from the SQL query
     *
     * @returns a dictionary that you can index values from the result
     */
    private getASValues;
    /**
     * Takes the dimension and creates the select and where statement
     * for querying the defined bins
     *
     * @returns select and where statement as strings
     */
    private binSQLCategorical;
    /**
     * Takes the dimension and creates the select and where statement
     * for querying the defined bins
     *
     * @returns select and where statement as strings
     */
    private binSQL;
    /**
     * Converts the filters (intervals) into SQL WHERE clauses as strings
     *
     * @returns map of filters but in string format that can be queried with SQL
     * instead of Intervals
     */
    private filtersToSQLWhereClauses;
    /**
     * Constructs SQL select and where clause over the total number
     * of pixels/resolution
     *
     * @returns select and where statement as strings
     */
    private binSQLPixel;
}

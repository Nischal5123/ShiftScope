import { Table } from "apache-arrow";
import { BitSet } from "../bitset";
import { FalconDB } from "./db";
import { Row } from "../iterator";
import { View1D } from "../views";
import type { Vector } from "apache-arrow";
import type { Filters, FalconCounts, FalconIndex, FalconCube } from "./db";
import type { CategoricalRange, ContinuousDimension, ContinuousRange, Dimension } from "../dimension";
import type { BinNumberFunction } from "../util";
import type { View } from "../views";
type DimensionFilterHash = string;
type FilterMasks<T> = Map<T, BitSet>;
export declare class ArrowDB implements FalconDB {
    readonly blocking: boolean;
    data: Table;
    filterMaskIndex: FilterMasks<DimensionFilterHash>;
    /**
     * Falcon Database using arrow data columnar table
     *
     * Starts by saving data by reference and
     * indicates that we have synchronous calls that are blocking
     *
     * @note [arrow specification](https://arrow.apache.org/docs/format/Columnar.html)
     * @note [arrow wes mckinney video](https://www.youtube.com/watch?v=fyj4FyH3XdU)
     */
    constructor(data: Table, filterMaskCacheSize?: number);
    /**
     * Easy helper method to create a new ArrowDB from an arrow file
     *
     * @todo think about if we should even support this
     * @returns a new ArrowDB object with the arrow data from the file
     */
    static fromArrowFile(url: string): Promise<ArrowDB>;
    /**
     * compute the best number of bins for a histogram
     * given the data
     *
     * @resource [plot](https://github.com/observablehq/plot/blob/97924e7682e49d35a34da794ca98bf0c7e8a3c28/src/transforms/bin.js#L320)
     * @resource [lord and savior](https://twitter.com/mbostock/status/1429281697854464002)
     * @resource [numpy](https://numpy.org/doc/stable/reference/generated/numpy.histogram_bin_edges.html)
     */
    estimateNumBins(dimension: ContinuousDimension, maxThreshold?: number, noKnowledgeEstimate?: number): number;
    length(filters?: Filters): number;
    range(dimension: Dimension): ContinuousRange | CategoricalRange;
    dimensionExists(dimension: Dimension): boolean;
    tableExists(): boolean;
    entries(offset?: number, length?: number, filters?: Filters | undefined): Promise<Iterable<Row | null>>;
    histogramView1D(view: View1D, filters?: Filters): FalconCounts;
    /**
     * Given an active view, computes the falcon cube for each passive view and stores it in the falcon index (map)
     * @param activeView
     * @param passiveViews
     * @param filters
     * @returns a map of passive view to falcon cube
     */
    falconIndexView1D(activeView: View1D, passiveViews: View[], filters: Filters): FalconIndex;
    private excludeDimensionsFilterMasks;
    /**
     * Takes a view and computes the falcon cube for that passive view
     * more details in the [paper](https://idl.cs.washington.edu/files/2019-Falcon-CHI.pdf)
     *
     * @note Only works for 0D and 1D continuous views at the moment
     * @returns a cube as FalconArray for the passive view
     */
    cubeSlice1DCategorical(view: View, activeCol: Vector, filterMasks: FilterMasks<Dimension>, binCountActive: number, binActive: BinNumberFunction): FalconCube;
    /**
     * Takes a view and computes the falcon cube for that passive view
     * more details in the [paper](https://idl.cs.washington.edu/files/2019-Falcon-CHI.pdf)
     *
     * @note Only works for 0D and 1D continuous views at the moment
     * @returns a cube as FalconArray for the passive view
     */
    cubeSlice1DContinuous(view: View, activeCol: Vector, filterMasks: FilterMasks<Dimension>, numPixels: number, binActive: BinNumberFunction): FalconCube;
    /**
     * given the dimension and filters
     *
     * @returns a map of the filter masks
     */
    private getFilterMasks;
    /**
     * Gets filter mask given the filter (extent for now)
     *
     * @returns a bitmask of which 1 if the row value should be included or 0 if not
     */
    private getCategoricalFilterMask;
    /**
     * Gets filter mask given the filter (extent for now)
     *
     * @returns a bitmask of which 1 if the row value should be included or 0 if not
     */
    private getContinuousFilterMask;
}
export {};

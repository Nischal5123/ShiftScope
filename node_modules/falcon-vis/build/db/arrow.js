import { tableFromIPC } from "apache-arrow";
import { BitSet, union } from "../bitset";
import { greatScott } from "../bins";
import { FalconArray } from "../falconArray";
import { RowIterator } from "../iterator";
import { binNumberFunctionContinuous, binNumberFunctionPixels, numBinsContinuous, numBinsCategorical, binNumberFunctionCategorical, } from "../util";
import { View0D, View1D } from "../views";
export class ArrowDB {
    /**
     * Falcon Database using arrow data columnar table
     *
     * Starts by saving data by reference and
     * indicates that we have synchronous calls that are blocking
     *
     * @note [arrow specification](https://arrow.apache.org/docs/format/Columnar.html)
     * @note [arrow wes mckinney video](https://www.youtube.com/watch?v=fyj4FyH3XdU)
     */
    constructor(data, filterMaskCacheSize = 64) {
        this.blocking = true;
        // bitmask to determine what rows filter out or not
        this.filterMaskIndex = new LimitedMap(filterMaskCacheSize); // only save a few recent filter masks in memory
        this.data = data;
    }
    /**
     * Easy helper method to create a new ArrowDB from an arrow file
     *
     * @todo think about if we should even support this
     * @returns a new ArrowDB object with the arrow data from the file
     */
    static async fromArrowFile(url) {
        const data = await fetch(url);
        const buffer = await data.arrayBuffer();
        const table = tableFromIPC(buffer);
        return new ArrowDB(table);
    }
    /**
     * compute the best number of bins for a histogram
     * given the data
     *
     * @resource [plot](https://github.com/observablehq/plot/blob/97924e7682e49d35a34da794ca98bf0c7e8a3c28/src/transforms/bin.js#L320)
     * @resource [lord and savior](https://twitter.com/mbostock/status/1429281697854464002)
     * @resource [numpy](https://numpy.org/doc/stable/reference/generated/numpy.histogram_bin_edges.html)
     */
    estimateNumBins(dimension, maxThreshold = 200, noKnowledgeEstimate = 15) {
        const arrowColumn = this.data.getChild(dimension.name);
        if (arrowColumn.length <= 1) {
            // can't do much with one data point
            return 1;
        }
        if (dimension.range) {
            const standardDeviation = Math.sqrt(arrowColumnSampleVariance(arrowColumn)); // \sqrt{\sigma^2}
            const [min, max] = dimension.range;
            const optimalBins = greatScott(min, max, standardDeviation);
            return Math.min(optimalBins, maxThreshold);
        }
        // if we don't have a min max range, just return the no knowledge estimate
        return noKnowledgeEstimate;
    }
    length(filters) {
        if (filters) {
            const filterMask = union(...this.getFilterMasks(filters).values());
            let total = 0;
            for (const bit of filterMask) {
                // if the bit is not set (aka false) then add 1 to the total
                if (bit === false) {
                    total++;
                }
            }
            return total;
        }
        else {
            return this.data.numRows;
        }
    }
    range(dimension) {
        const arrowColumn = this.data.getChild(dimension.name);
        const arrowColumnExists = arrowColumn !== null;
        if (arrowColumnExists) {
            if (dimension.type === "continuous") {
                return arrowColumnExtent(arrowColumn);
            }
            else if (dimension.type === "categorical") {
                return arrowColumnUnique(arrowColumn).filter((item) => item !== null);
            }
            else {
                throw Error("Unsupported Dimension type for range");
            }
        }
        else {
            throw Error("Dimension name does not exist in arrow table");
        }
    }
    dimensionExists(dimension) {
        return this.data.getChild(dimension.name) !== null;
    }
    tableExists() {
        return this.data && this.data.numCols > 0;
    }
    async entries(offset = 0, length = Infinity, filters) {
        const filterMask = union(...this.getFilterMasks(filters ?? new Map()).values());
        return new RowIterator(this.data.numRows, (i) => this.data.get(i), filterMask, offset, length);
    }
    histogramView1D(view, filters) {
        let filter;
        let noFilter;
        let bin;
        let binCount;
        // 1. decide which rows are filtered or not
        const filterMask = union(...this.getFilterMasks(filters ?? new Map()).values());
        // 2. allocate memory for the bins
        if (view.dimension.type === "continuous") {
            const binConfig = view.dimension.binConfig;
            binCount = numBinsContinuous(binConfig);
            bin = binNumberFunctionContinuous(binConfig);
        }
        else if (view.dimension.type === "categorical") {
            binCount = numBinsCategorical(view.dimension.range);
            bin = binNumberFunctionCategorical(view.dimension.range);
        }
        else {
            throw new Error("Unsupported dimension type for array allocation");
        }
        noFilter = FalconArray.allocCounts(binCount);
        filter = filterMask ? FalconArray.allocCounts(binCount) : noFilter;
        // 3. iterate over the row values and determine which bin to increment
        const column = this.data.getChild(view.dimension.name);
        for (let i = 0; i < this.data.numRows; i++) {
            const value = column.get(i);
            const binLocation = bin(value);
            // increment the specific bin
            if (0 <= binLocation && binLocation < binCount && isValidValue(value)) {
                noFilter.increment([binLocation]);
                if (filterMask && !filterMask.get(i)) {
                    filter.increment([binLocation]);
                }
            }
        }
        // 5. return the results
        return {
            noFilter,
            filter,
        };
    }
    /**
     * Given an active view, computes the falcon cube for each passive view and stores it in the falcon index (map)
     * @param activeView
     * @param passiveViews
     * @param filters
     * @returns a map of passive view to falcon cube
     */
    falconIndexView1D(activeView, passiveViews, filters) {
        const activeCol = this.data.getChild(activeView.dimension.name);
        const filterMasks = this.getFilterMasks(filters);
        const cubes = new Map();
        let binCountActive;
        let binActive; // maps a value to a bin index
        // first compute the binning function for the active view
        if (activeView.dimension.type === "continuous") {
            const pixels = activeView.dimension.resolution;
            const numPixels = activeView.dimension.resolution + 1; // extending by one pixel so we can compute the right diff later
            binActive = binNumberFunctionPixels(activeView.dimension.binConfig, pixels);
            binCountActive = numPixels;
        }
        else if (activeView.dimension.type === "categorical") {
            binActive = binNumberFunctionCategorical(activeView.dimension.range);
            binCountActive = numBinsCategorical(activeView.dimension.range);
        }
        else {
            throw new Error("Unsupported dimension type for index1D");
        }
        // then compute cubes
        if (activeView.dimension.type === "continuous") {
            passiveViews.forEach((view) => {
                const cube = this.cubeSlice1DContinuous(view, activeCol, filterMasks, binCountActive, binActive);
                cubes.set(view, cube);
            });
        }
        else {
            passiveViews.forEach((view) => {
                const cube = this.cubeSlice1DCategorical(view, activeCol, filterMasks, binCountActive, binActive);
                cubes.set(view, cube);
            });
        }
        return cubes;
    }
    excludeDimensionsFilterMasks(view, filterMasks) {
        // 2.1 only filter all other dimensions (filter on same dimension does not apply)
        const relevantMasks = new Map(filterMasks);
        if (view instanceof View0D) {
            // use all filters
        }
        else if (view instanceof View1D) {
            // remove itself from filtering
            relevantMasks.delete(view.dimension);
        }
        return relevantMasks;
    }
    /**
     * Takes a view and computes the falcon cube for that passive view
     * more details in the [paper](https://idl.cs.washington.edu/files/2019-Falcon-CHI.pdf)
     *
     * @note Only works for 0D and 1D continuous views at the moment
     * @returns a cube as FalconArray for the passive view
     */
    cubeSlice1DCategorical(view, activeCol, filterMasks, binCountActive, binActive) {
        let noFilter;
        let filter;
        // don't have a passive view filter itself
        const relevantMasks = this.excludeDimensionsFilterMasks(view, filterMasks);
        const filterMask = union(...relevantMasks.values());
        if (view instanceof View0D) {
            filter = FalconArray.allocCounts(binCountActive);
            noFilter = FalconArray.allocCounts(1, [1]);
            // add data to aggregation matrix
            for (let i = 0; i < this.data.numRows; i++) {
                // ignore filtered entries
                if (filterMask && filterMask.get(i)) {
                    continue;
                }
                const keyActive = binActive(activeCol.get(i));
                if (0 <= keyActive && keyActive < binCountActive) {
                    filter.increment([keyActive]);
                }
                noFilter.increment([0]);
            }
        }
        else if (view instanceof View1D) {
            let binPassive;
            let binCount;
            if (view.dimension.type === "continuous") {
                // continuous bins for passive view that we accumulate across
                const binConfig = view.dimension.binConfig;
                binPassive = binNumberFunctionContinuous(binConfig);
                binCount = numBinsContinuous(binConfig);
            }
            else {
                // categorical bins for passive view that we accumulate across
                binPassive = binNumberFunctionCategorical(view.dimension.range);
                binCount = numBinsCategorical(view.dimension.range);
            }
            filter = FalconArray.allocCounts(binCountActive * binCount, [
                binCountActive,
                binCount,
            ]);
            noFilter = FalconArray.allocCounts(binCount, [binCount]);
            const passiveCol = this.data.getChild(view.dimension.name);
            // add data to aggregation matrix
            for (let i = 0; i < this.data.numRows; i++) {
                // ignore filtered entries
                if (filterMask && filterMask.get(i)) {
                    continue;
                }
                const valueActive = activeCol.get(i);
                const valuePassive = passiveCol.get(i);
                const keyPassive = binPassive(valuePassive);
                const keyActive = binActive(valueActive);
                if (0 <= keyPassive &&
                    keyPassive < binCount &&
                    isValidValue(valuePassive)) {
                    if (0 <= keyActive &&
                        keyActive < binCountActive &&
                        isValidValue(valueActive)) {
                        filter.increment([keyActive, keyPassive]);
                    }
                    noFilter.increment([keyPassive]);
                }
            }
        }
        else {
            throw Error("Unsupported passive view type in cube computation");
        }
        return { noFilter, filter };
    }
    /**
     * Takes a view and computes the falcon cube for that passive view
     * more details in the [paper](https://idl.cs.washington.edu/files/2019-Falcon-CHI.pdf)
     *
     * @note Only works for 0D and 1D continuous views at the moment
     * @returns a cube as FalconArray for the passive view
     */
    cubeSlice1DContinuous(view, activeCol, filterMasks, numPixels, binActive) {
        let noFilter;
        let filter;
        // don't have a passive view filter itself
        const relevantMasks = this.excludeDimensionsFilterMasks(view, filterMasks);
        const filterMask = union(...relevantMasks.values());
        // 2.2 this count counts for each pixel wise bin
        if (view instanceof View0D) {
            filter = FalconArray.allocCumulative(numPixels);
            noFilter = FalconArray.allocCounts(1, [1]);
            // add data to aggregation matrix
            for (let i = 0; i < this.data.numRows; i++) {
                // ignore filtered entries
                if (filterMask && filterMask.get(i)) {
                    continue;
                }
                const valueActive = activeCol.get(i);
                const keyActive = binActive(valueActive) + 1;
                if (0 <= keyActive &&
                    keyActive < numPixels &&
                    isValidValue(valueActive)) {
                    filter.increment([keyActive]);
                }
                noFilter.increment([0]);
            }
            // falcon magic sauce
            filter.cumulativeSum();
        }
        else if (view instanceof View1D) {
            let binPassive;
            let binCount;
            if (view.dimension.type === "continuous") {
                // continuous bins for passive view that we accumulate across
                const binConfig = view.dimension.binConfig;
                binPassive = binNumberFunctionContinuous(binConfig);
                binCount = numBinsContinuous(binConfig);
            }
            else {
                // categorical bins for passive view that we accumulate across
                binPassive = binNumberFunctionCategorical(view.dimension.range);
                binCount = numBinsCategorical(view.dimension.range);
            }
            filter = FalconArray.allocCumulative(numPixels * binCount, [
                numPixels,
                binCount,
            ]);
            noFilter = FalconArray.allocCounts(binCount, [binCount]);
            const passiveCol = this.data.getChild(view.dimension.name);
            // add data to aggregation matrix
            for (let i = 0; i < this.data.numRows; i++) {
                // ignore filtered entries
                if (filterMask && filterMask.get(i)) {
                    continue;
                }
                const valueActive = activeCol.get(i);
                const valuePassive = passiveCol.get(i);
                const keyActive = binActive(valueActive) + 1;
                const keyPassive = binPassive(valuePassive);
                if (0 <= keyPassive &&
                    keyPassive < binCount &&
                    isValidValue(valuePassive)) {
                    if (0 <= keyActive &&
                        keyActive < numPixels &&
                        isValidValue(valueActive)) {
                        filter.increment([keyActive, keyPassive]);
                    }
                    noFilter.increment([keyPassive]);
                }
            }
            for (let passiveBinIndex = 0; passiveBinIndex < filter.shape[1]; passiveBinIndex++) {
                // sum across column (passive bin aggregate)
                filter.slice(null, passiveBinIndex).cumulativeSum();
            }
        }
        else {
            throw Error("only 0D and 1D views");
        }
        return {
            noFilter,
            filter,
        };
    }
    /**
     * given the dimension and filters
     *
     * @returns a map of the filter masks
     */
    getFilterMasks(filters) {
        // no filters just return blank
        if (!filters.size) {
            return new Map();
        }
        // extract filters from the larger cache index into this compact one
        const compactIndex = new Map();
        for (const [dimension, filter] of filters) {
            let mask;
            if (dimension.type === "continuous") {
                mask = this.getContinuousFilterMask(dimension, filter);
            }
            else {
                mask = this.getCategoricalFilterMask(dimension, filter);
            }
            compactIndex.set(dimension, mask);
        }
        return compactIndex;
    }
    /**
     * Gets filter mask given the filter (extent for now)
     *
     * @returns a bitmask of which 1 if the row value should be included or 0 if not
     */
    getCategoricalFilterMask(dimension, filter) {
        const filterSet = new Set(filter);
        const key = `${dimension.name} ${filter}`;
        // if not in the cache, compute it and add it!
        const notFound = !this.filterMaskIndex.has(key);
        if (notFound) {
            // compute filter mask
            const column = this.data.getChild(dimension.name);
            const mask = arrowFilterMask(column, (rowValue) => filterSet.has(rowValue));
            // set the cache
            this.filterMaskIndex.set(key, mask);
        }
        // return the value of the mask
        return this.filterMaskIndex.get(key);
    }
    /**
     * Gets filter mask given the filter (extent for now)
     *
     * @returns a bitmask of which 1 if the row value should be included or 0 if not
     */
    getContinuousFilterMask(dimension, filter) {
        const key = `${dimension.name} ${filter}`;
        // if not in the cache, compute it and add it!
        const notFound = !this.filterMaskIndex.has(key);
        if (notFound) {
            // compute filter mask
            const column = this.data.getChild(dimension.name);
            const mask = arrowFilterMask(column, (value) => value > filter[0] && value <= filter[1]);
            // set the cache
            this.filterMaskIndex.set(key, mask);
        }
        // return the value of the mask
        return this.filterMaskIndex.get(key);
    }
}
/**
 * determines if the value from the arrow column is valid
 */
function isValidValue(value) {
    return value !== null;
}
/**
 * given an arrow column vector, create a filter mask
 *
 * @note uses bitmask to reduce space and allow for potential computer optimizations
 * @note should filter => true corresponds to filter out and false keeps
 * @returns a bitmask that indicates if the values should be included (1) or not (0)
 */
function arrowFilterMask(column, shouldKeep) {
    const bitmask = new BitSet(column.length);
    /**
     * iterate each row value in the column and decide if we should
     * keep it or not
     *
     * bit 1 indicates filter
     * bit 0 indicates keep
     */
    for (let i = 0; i < column.length; i++) {
        const rowValue = column.get(i);
        if (!shouldKeep(rowValue)) {
            bitmask.set(i, true);
        }
    }
    return bitmask;
}
/**
 * Takes all unique values and returns it into an array
 *
 * @returns unique values in an array
 */
function arrowColumnUnique(column) {
    const unique = new Set();
    for (const rowValue of column) {
        unique.add(rowValue);
    }
    return Array.from(unique);
}
/**
 * extent over a single columnar vector from arrow
 *
 * @returns the [min, max] of the column values
 */
function arrowColumnExtent(column) {
    const firstRowValue = column.get(0);
    let max = firstRowValue;
    let min = firstRowValue;
    for (const rowValue of column) {
        // if we found something BIGGER the max, that should be the max instead!
        if (rowValue > max) {
            max = rowValue;
        }
        // if we found something SMALLER the min, that should be the min instead!
        else if (rowValue < min) {
            min = rowValue;
        }
    }
    return [Number(min), Number(max)];
}
/**
 * sample defined by
 * $$\sigma^2 = \frac{1}{n} \sum_{i=1}^n (x_i - \mu)^2$$
 *
 * this can probably be optimized faster to be like [the boss](https://github.com/d3/d3-array/blob/main/src/variance.js#L1)
 */
function arrowColumnSampleVariance(vector) {
    let variance = 0, n = vector.length;
    let mu = arrowColumnMean(vector);
    for (const x_i of vector) {
        variance += (x_i - mu) ** 2;
    }
    return n > 1 ? variance / (n - 1) : variance;
}
function arrowColumnMean(vector) {
    let mean = 0, n = vector.length;
    for (const x_i of vector) {
        mean += x_i;
    }
    return mean / n;
}
class LimitedMap extends Map {
    /**
     * A Map that only keeps the most recent `limit` number of entries.
     * @param limit - The maximum size of the map.
     */
    constructor(limit) {
        super();
        this.limit = limit;
    }
    set(key, value) {
        if (this.size >= this.limit) {
            this.delete(this.keys().next().value);
        }
        return super.set(key, value);
    }
}
//# sourceMappingURL=arrow.js.map
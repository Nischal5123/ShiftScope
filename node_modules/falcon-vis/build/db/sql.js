import { greatScott } from "../bins";
import { FalconArray } from "../falconArray";
import { binNumberFunctionContinuousSQL, binNumberFunctionCategorical, numBinsCategorical, numBinsContinuous, stepSize, } from "../util";
import { View0D, View1D } from "../views";
export class SQLDB {
    constructor(table, nameMap) {
        this.table = table;
        this.nameMap = nameMap;
    }
    castBins(input) {
        return `${input}`;
    }
    /**
     * if the column is a time/date column, there may be some modifying
     * for example, in duckdb we have to do this bs epoch(name)*1000 to convert the date into milliseconds UTC
     */
    castTime(name) {
        return `epoch(${name})*1000`;
    }
    /**
     * intermediary function incase we mapped the names to something else
     * change this if you for example have issues with time dimensions
     *
     * @returns mapped string name defined from constructor
     */
    getName(dimension) {
        let name = this.nameMap?.get(dimension.name) ?? dimension.name;
        if (dimension.type === "continuous" && dimension.time) {
            name = this.castTime(name);
        }
        return name;
    }
    async dimensionExists(dimension) {
        const result = await this.query(`SELECT EXISTS 
      (SELECT 0 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '${this.table}' AND COLUMN_NAME = '${dimension.name}') as _exists`);
        const { _exists } = this.getASValues(result);
        return _exists;
    }
    async tableExists() {
        const result = await this.query(`SELECT EXISTS 
      (SELECT 0 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = '${this.table}') as _exists`);
        const { _exists } = this.getASValues(result);
        return _exists;
    }
    async entries(offset = 0, length = Infinity, filters) {
        const where = filters
            ? [...this.filtersToSQLWhereClauses(filters).values()].join(" AND ")
            : undefined;
        const additionalNames = this.nameMap?.values() ?? [];
        const filteredTable = await this.query(`SELECT *, ${Array.from(additionalNames)}
              FROM ${this.table}
              ${where ? `WHERE ${where}` : ""}
              ${length >= 0 && length < Infinity ? `LIMIT ${length}` : ""}
              OFFSET ${offset}`);
        return filteredTable;
    }
    /**
     * compute the best number of bins for a histogram
     * given the data
     *
     * @resource [plot](https://github.com/observablehq/plot/blob/97924e7682e49d35a34da794ca98bf0c7e8a3c28/src/transforms/bin.js#L320)
     * @resource [lord and savior](https://twitter.com/mbostock/status/1429281697854464002)
     * @resource [numpy](https://numpy.org/doc/stable/reference/generated/numpy.histogram_bin_edges.html)
     */
    async estimateNumBins(dimension, maxThreshold = 200, noKnowledgeEstimate = 15) {
        const count = await this.length();
        if (count <= 1) {
            return 1;
        }
        if (dimension.range) {
            const standardDeviationQuery = await this.query(`SELECT STDDEV(${this.getName(dimension)}) AS standardDeviation FROM ${this.table}`);
            const { standardDeviation } = this.getASValues(standardDeviationQuery);
            const [min, max] = dimension.range;
            const optimalBins = greatScott(min, max, standardDeviation);
            return Math.min(optimalBins, maxThreshold);
        }
        // if we don't have a min max range, just return the no knowledge estimate
        return noKnowledgeEstimate;
    }
    async length(filters) {
        let filterSQL = "";
        if (filters) {
            filterSQL = [...this.filtersToSQLWhereClauses(filters).values()].join(" AND ");
        }
        const result = await this.query(`SELECT count(*) AS _count
       FROM ${this.table}
       ${filterSQL ? `WHERE ${filterSQL}` : ""}`);
        const { _count } = this.getASValues(result);
        return _count;
    }
    async range(dimension) {
        const field = this.getName(dimension);
        if (dimension.type === "continuous") {
            const result = await this.query(`SELECT  MIN(${field}) AS _min, MAX(${field}) AS _max
        FROM ${this.table}`);
            const { _min, _max } = this.getASValues(result);
            // may be bigints so cast to numbers
            return [Number(_min), Number(_max)];
        }
        else {
            const result = await this.query(`SELECT DISTINCT "${field}" AS _unique FROM ${this.table}`);
            let range = [];
            for (const { _unique } of result) {
                range.push(_unique);
            }
            return range.filter((x) => x !== null);
        }
    }
    async histogramView1D(view, filters) {
        let binCount;
        let bSql;
        let bin;
        // construct binning scheme
        if (view.dimension.type === "continuous") {
            binCount = numBinsContinuous(view.dimension.binConfig);
            bSql = this.binSQL(view.dimension, view.dimension.binConfig);
            bin = (x) => x;
        }
        else {
            binCount = numBinsCategorical(view.dimension.range);
            bSql = this.binSQLCategorical(view.dimension, view.dimension.range);
            bin = binNumberFunctionCategorical(view.dimension.range);
        }
        // allocate memory
        const noFilter = FalconArray.allocCounts(binCount);
        const hasFilters = filters && filters.size > 0;
        const filter = hasFilters ? FalconArray.allocCounts(binCount) : noFilter;
        // query and store when no filters are active
        const result = await this.query(`SELECT ${bSql.select}
       AS binIndex, count(*) AS binCount
       FROM ${this.table} 
       WHERE ${bSql.where} 
       GROUP BY binIndex`);
        for (const { binIndex, binCount } of result) {
            noFilter.set(bin(binIndex), binCount);
        }
        // query and store if we have filters
        if (hasFilters) {
            const where = [...this.filtersToSQLWhereClauses(filters).values()].join(" AND ");
            const queryText = `SELECT ${bSql.select}
         AS binIndex, count(*) AS binCount
         FROM ${this.table}
         WHERE ${bSql.where} AND ${where} 
         GROUP BY binIndex`;
            const result = await this.query(queryText);
            for (const { binIndex, binCount } of result) {
                filter.set(binIndex, binCount);
            }
        }
        return { filter, noFilter };
    }
    falconIndexView1D(activeView, passiveViews, filters) {
        const t0 = performance.now();
        const sqlFilters = this.filtersToSQLWhereClauses(filters);
        const cubes = new Map();
        if (activeView.dimension.type === "continuous") {
            // 1. active bin for each pixel
            const numPixelBins = activeView.dimension.resolution;
            const binActive = this.binSQLPixel(activeView.dimension, activeView.dimension.binConfig, numPixelBins);
            const numPixels = numPixelBins + 1; // for example 10 bins -> 11 total edges (pixels)
            // 2. iterate through passive views and compute cubes
            const promises = [];
            passiveViews.forEach((view) => {
                const cube = this.cubeSlice1DContinuous(view, sqlFilters, binActive, numPixels);
                promises.push(cube);
                cubes.set(view, cube);
            });
            // Merge promises into one, when all resolve .then will hit
            Promise.all(promises).then(() => {
                console.info(`Build index: ${performance.now() - t0}ms`);
            });
        }
        else {
            // 1. active bin for each pixel
            const binActive = this.binSQLCategorical(activeView.dimension, activeView.dimension.range);
            const numBins = numBinsCategorical(activeView.dimension.range);
            const binActiveIndexMap = binNumberFunctionCategorical(activeView.dimension.range);
            // 2. iterate through passive views and compute cubes
            const promises = [];
            passiveViews.forEach((view) => {
                const cube = this.cubeSlice1DCategorical(view, sqlFilters, binActive, binActiveIndexMap, numBins);
                promises.push(cube);
                cubes.set(view, cube);
            });
            // Merge promises into one, when all resolve .then will hit
            Promise.all(promises).then(() => {
                console.info(`Build index: ${performance.now() - t0}ms`);
            });
        }
        return cubes;
    }
    async cubeSlice1DCategorical(view, sqlFilters, binActive, binActiveIndexMap, binCountActive) {
        let noFilter;
        let filter;
        const relevantFilters = new Map(sqlFilters);
        if (view instanceof View0D) {
            // use all filters
        }
        else if (view instanceof View1D) {
            // remove itself from filtering
            relevantFilters.delete(view.dimension);
        }
        const where = [...relevantFilters.values()].join(" AND ");
        let query = ``;
        let binPassiveIndexMap = (x) => x;
        const select = `CASE WHEN ${binActive.where} 
     THEN ${binActive.select}
     ELSE -1 END AS "keyActive",
     count(*) AS cnt`;
        if (view instanceof View0D) {
            filter = FalconArray.allocCounts(binCountActive);
            noFilter = FalconArray.allocCounts(1, [1]);
            query = `SELECT ${select}
         FROM ${this.table} 
         ${where ? `WHERE ${where}` : ""} 
         GROUP BY "keyActive"`;
        }
        else if (view instanceof View1D) {
            let binPassive;
            let binCount;
            if (view.dimension.type === "continuous") {
                // continuous bins for passive view that we accumulate across
                const binConfig = view.dimension.binConfig;
                binCount = numBinsContinuous(binConfig);
                binPassive = this.binSQL(view.dimension, view.dimension.binConfig);
            }
            else {
                // categorical bins for passive view that we accumulate across
                binPassiveIndexMap = binNumberFunctionCategorical(view.dimension.range);
                binCount = numBinsCategorical(view.dimension.range);
                binPassive = this.binSQLCategorical(view.dimension, view.dimension.range);
            }
            filter = FalconArray.allocCounts(binCountActive * binCount, [
                binCountActive,
                binCount,
            ]);
            noFilter = FalconArray.allocCounts(binCount, [binCount]);
            query = `SELECT ${select}, 
       ${binPassive.select} AS key 
       FROM ${this.table} 
       WHERE ${binPassive.where} ${where ? `AND ${where}` : ""} 
       GROUP BY "keyActive", key`;
        }
        else {
            throw Error("no 2d view here");
        }
        const result = await this.query(query);
        if (view instanceof View0D) {
            for (const { keyActive, cnt } of result) {
                const binIndex = binActiveIndexMap(keyActive);
                if (binIndex >= 0) {
                    filter.set(binIndex, cnt);
                }
                noFilter.increment([0], cnt);
            }
        }
        else if (view instanceof View1D) {
            for (const { keyActive, key, cnt } of result) {
                const binActiveIndex = binActiveIndexMap(keyActive);
                const binPassiveIndex = binPassiveIndexMap(key);
                if (binActiveIndex >= 0) {
                    filter.set(binActiveIndex, binPassiveIndex, cnt);
                }
                noFilter.increment([binPassiveIndex], cnt);
            }
        }
        else {
            throw Error();
        }
        return { noFilter, filter };
    }
    /**
     * Takes a view and computes the falcon cube for that passive view
     * more details in the [paper](https://idl.cs.washington.edu/files/2019-Falcon-CHI.pdf)
     *
     * @note Only works for 0D and 1D continuous views at the moment
     * @returns a cube as FalconArray for the passive view
     */
    async cubeSlice1DContinuous(view, sqlFilters, binActive, numPixels) {
        let noFilter;
        let filter;
        const relevantFilters = new Map(sqlFilters);
        if (view instanceof View0D) {
            // use all filters
        }
        else if (view instanceof View1D) {
            // remove itself from filtering
            relevantFilters.delete(view.dimension);
        }
        const where = [...relevantFilters.values()].join(" AND ");
        let query;
        let binPassiveIndexMap = (x) => x;
        const select = `CASE
     WHEN ${binActive.where} 
     THEN ${binActive.select}
     ELSE -1 END AS "keyActive",
     count(*) AS cnt`;
        if (view instanceof View0D) {
            filter = FalconArray.allocCumulative(numPixels);
            noFilter = FalconArray.allocCounts(1, [1]);
            query = `SELECT ${select}
         FROM ${this.table} 
         ${where ? `WHERE ${where}` : ""} 
         GROUP BY "keyActive"`;
        }
        else if (view instanceof View1D) {
            let passiveBin;
            let binCount;
            if (view.dimension.type === "continuous") {
                const binConfig = view.dimension.binConfig;
                passiveBin = this.binSQL(view.dimension, binConfig);
                binCount = numBinsContinuous(binConfig);
            }
            else {
                passiveBin = this.binSQLCategorical(view.dimension, view.dimension.range);
                binCount = numBinsCategorical(view.dimension.range);
                binPassiveIndexMap = binNumberFunctionCategorical(view.dimension.range);
            }
            filter = FalconArray.allocCumulative(numPixels * binCount, [
                numPixels,
                binCount,
            ]);
            noFilter = FalconArray.allocCounts(binCount, [binCount]);
            query = `SELECT ${select}, 
       ${passiveBin.select} AS key 
       FROM ${this.table} 
       WHERE ${passiveBin.where} ${where ? `AND ${where}` : ""} 
       GROUP BY "keyActive", key`;
        }
        else {
            throw Error("only 0D and 1D views");
        }
        const result = await this.query(query);
        if (view instanceof View0D) {
            for (const { keyActive, cnt } of result) {
                if (keyActive >= 0) {
                    filter.set(keyActive + 1, cnt);
                }
                noFilter.increment([0], cnt);
            }
            filter.cumulativeSum();
        }
        else if (view instanceof View1D) {
            for (const { keyActive, key, cnt } of result) {
                const binPassiveIndex = binPassiveIndexMap(key);
                if (keyActive >= 0) {
                    filter.set(keyActive + 1, binPassiveIndex, cnt);
                }
                noFilter.increment([binPassiveIndex], cnt);
            }
            // compute cumulative sums
            for (let passiveBinIndex = 0; passiveBinIndex < filter.shape[1]; passiveBinIndex++) {
                // sum across column (passive bin aggregate)
                filter.slice(null, passiveBinIndex).cumulativeSum();
            }
        }
        else {
            throw Error("only 0D and 1D views");
        }
        return { filter, noFilter };
    }
    /**
     * Easily extract the "as" values from the SQL query
     *
     * @returns a dictionary that you can index values from the result
     */
    getASValues(result) {
        return result[Symbol.iterator]().next().value;
    }
    /**
     * Takes the dimension and creates the select and where statement
     * for querying the defined bins
     *
     * @returns select and where statement as strings
     */
    binSQLCategorical(dimension, range) {
        const field = this.getName(dimension);
        const select = `"${field}"`;
        const where = categoricalWhereSQL(field, range);
        return {
            select,
            where,
        };
    }
    /**
     * Takes the dimension and creates the select and where statement
     * for querying the defined bins
     *
     * @returns select and where statement as strings
     */
    binSQL(dimension, binConfig) {
        const field = this.getName(dimension);
        const select = binNumberFunctionContinuousSQL(field, binConfig, this.castBins);
        const where = `${field} BETWEEN ${binConfig.start} AND ${binConfig.stop}`;
        return {
            select,
            where,
        };
    }
    /**
     * Converts the filters (intervals) into SQL WHERE clauses as strings
     *
     * @returns map of filters but in string format that can be queried with SQL
     * instead of Intervals
     */
    filtersToSQLWhereClauses(filters) {
        const whereClauses = new Map();
        for (const [dimension, range] of filters) {
            const field = this.getName(dimension);
            let whereClause;
            if (dimension.type === "continuous") {
                whereClause = `${field} BETWEEN ${range[0]} AND ${range[1]}`;
            }
            else {
                whereClause = categoricalWhereSQL(field, range);
            }
            whereClauses.set(dimension, whereClause);
        }
        return whereClauses;
    }
    /**
     * Constructs SQL select and where clause over the total number
     * of pixels/resolution
     *
     * @returns select and where statement as strings
     */
    binSQLPixel(dimension, binConfig, pixels) {
        const step = pixels !== undefined ? stepSize(binConfig, pixels) : binConfig.step;
        const start = binConfig.start;
        return this.binSQL(dimension, { ...binConfig, start, step });
    }
}
function categoricalWhereSQL(field, range) {
    let where = `"${field}" in (`;
    range.forEach((r) => {
        if (r !== null) {
            where += `'${r}', `;
        }
    });
    where += `)`;
    const hasNull = range.findIndex((r) => r === null) !== -1;
    if (hasNull) {
        where += ` OR "${field}" IS NULL`;
    }
    return where;
}
//# sourceMappingURL=sql.js.map
import { CumulativeCountsArray, CountsArray } from "./arrayTypes";
import ndarray from "ndarray";
import prefixSum from "ndarray-prefix-sum";
import ops from "ndarray-ops";
/**
 * abstract away the NdArray reliance and can be swapped out
 * for std lib js for example or vanilla, or tensorflow.js?
 *
 * @resource [PyTorch example of shape, stride, offset](https://www.youtube.com/watch?v=85xBkapaZts)
 */
export class FalconArray {
    constructor(data, shape, strides, offset) {
        this.data = data;
        this.ndarray = ndarray(data, shape, strides, offset);
    }
    /**
     * these GETS AND SETS can be replaced with
     * variables on the object when we phase out ndarray
     */
    get shape() {
        return this.ndarray.shape;
    }
    get offset() {
        return this.ndarray.offset;
    }
    get strides() {
        return this.ndarray.stride;
    }
    get length() {
        return this.ndarray.size;
    }
    set shape(value) {
        this.ndarray.shape = value;
    }
    set offset(value) {
        this.ndarray.offset = value;
    }
    set strides(value) {
        this.ndarray.stride = value;
    }
    get(...indices) {
        return this.ndarray.get(...indices);
    }
    set(...indices) {
        return this.ndarray.set(...indices);
    }
    fill(value) {
        this.data.fill(value);
    }
    /**
     * increments the location defined by index by
     * whatever you want!
     */
    increment(index, incrementBy = 1) {
        const location = this.ndarray.index(...index);
        this.data[location] += incrementBy;
    }
    /**
     * this + other and overrides this memory
     */
    addToItself(other) {
        ops.addeq(this.ndarray, other.ndarray);
        return this;
    }
    /**
     * this - other and overrides this memory
     */
    subToItself(other) {
        ops.subeq(this.ndarray, other.ndarray);
        return this;
    }
    /**
     * this + other = new memory
     */
    add(other, ReturnArray = CountsArray) {
        const out = new FalconArray(new ReturnArray(this.length), this.shape);
        ops.add(out.ndarray, this.ndarray, other.ndarray);
        return out;
    }
    /**
     * this - other = new memory
     */
    sub(other, ReturnArray = CountsArray) {
        const out = new FalconArray(new ReturnArray(this.length), this.shape);
        ops.sub(out.ndarray, this.ndarray, other.ndarray);
        return out;
    }
    /**
     * slice by changing the shape, offset, or stride
     * no new memory created
     */
    slice(...indices) {
        const sliced = this.ndarray.pick(...indices);
        return new FalconArray(this.data, sliced.shape, sliced.stride, sliced.offset);
    }
    /**
     * prefix sum across and up
     */
    cumulativeSum() {
        prefixSum(this.ndarray);
        return this;
    }
    /**
     * @returns FalconArray with typed array
     */
    static typedArray(TypedArray, length, shape, stride, offset) {
        const newMemory = new TypedArray(length);
        return new FalconArray(newMemory, shape, stride, offset);
    }
    /**
     * Typed array to store and accumulate values
     * Float for this, but consider other options
     *
     * Namely for the cubes
     *
     * @returns FalconArray with the given length allocated
     */
    static allocCumulative(length, shape, stride, offset) {
        return this.typedArray(CumulativeCountsArray, length, shape, stride, offset);
    }
    /**
     * Typed array to store integer counts. Namely the histogram bins and counts.
     *
     * @returns FalconArray with the given length allocated
     */
    static allocCounts(length, shape, stride, offset) {
        return this.typedArray(CountsArray, length, shape, stride, offset);
    }
    toString2D() {
        let totalString = "";
        for (let i = 0; i < this.shape[0]; i++) {
            let row = "";
            for (let j = 0; j < this.shape[1]; j++) {
                row += this.get(i, j) + " ";
            }
            totalString += row + "\n";
        }
        return totalString;
    }
    toString1D() {
        let totalString = "";
        for (let i = 0; i < this.shape[0]; i++) {
            totalString += this.get(i) + " ";
        }
        return totalString;
    }
    toString() {
        if (this.shape.length === 1) {
            return this.toString1D();
        }
        else if (this.shape.length === 2) {
            return this.toString2D();
        }
        else {
            return "not implemented yet";
        }
    }
    deepCopy(ArrayType) {
        const copy = FalconArray.typedArray(ArrayType, this.length, this.shape, this.strides, this.offset);
        for (let i = 0; i < this.length; i++) {
            copy.data[i] = this.data[i];
        }
        return copy;
    }
}
FalconArray.ALL = null;
//# sourceMappingURL=falconArray.js.map
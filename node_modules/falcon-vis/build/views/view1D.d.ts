import { ViewAbstract } from "./viewAbstract";
import type { FalconVis } from "../falcon";
import type { CategoricalRange, Dimension, DimensionFilter } from "../dimension";
import type { Interval } from "../util";
import type { CountsArrayType } from "../falconArray/arrayTypes";
export interface ContinuousView1DState {
    total: CountsArrayType | null;
    filter: CountsArrayType | null;
    bin: {
        binStart: number;
        binEnd: number;
    }[] | null;
}
export interface CategoricalView1DState {
    total: CountsArrayType | null;
    filter: CountsArrayType | null;
    bin: any[] | null;
}
export type View1DState = CategoricalView1DState | ContinuousView1DState;
export declare class View1D extends ViewAbstract<View1DState> {
    dimension: Dimension;
    state: View1DState | CategoricalView1DState;
    toPixels: (brush: Interval<number>) => Interval<number>;
    lastFilter: DimensionFilter | undefined;
    constructor(falcon: FalconVis, dimension: Dimension);
    /**
     * slowest way to update data
     *
     * @todo this breaks when an active view is on
     * @todo replace this with targeted updates instead of just recomputing everything
     */
    update(dimension: Dimension): Promise<void>;
    /**
     * populates the extent in the dimension if not already defined
     *
     * @note that when the user does provide a binConfig, that will replace the range
     */
    createBins(): Promise<void>;
    /**
     *  initializes the counts for the view over the entire data
     *
     * @returns the View1D class itself
     */
    all(): Promise<this>;
    /**
     * prefetch the 1D falcon index
     */
    computeIndex(force?: boolean): Promise<void>;
    /**
     * activates this view: makes this view the active view
     *
     * this prefetches the falcon index under the hood that does all the speedups
     */
    activate(): Promise<void>;
    /**
     * compute counts from the falcon index
     */
    select(filter?: DimensionFilter, force?: boolean): Promise<void>;
    /**
     * Given an active 1D view, count for this passive view
     */
    countFromActiveContinuous1D(pixels?: Interval<number>): Promise<void>;
    /**
     * Given an active 1D view, count for this passive view
     */
    countFromActiveCategorical1D(selection?: CategoricalRange, totalRange?: CategoricalRange): Promise<void>;
    /**
     * attaches to the global falcon index
     */
    attach(): Promise<void>;
    /**
     * detaches from the global falcon index
     *
     * if I detach an active view, I need to relink
     */
    detach(): Promise<void>;
}

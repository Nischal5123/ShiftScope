import { ViewAbstract } from "./viewAbstract";
import { createBinConfigContinuous, binStartBinEndArray, brushToPixelSpace, binNumberFunctionCategorical, numBinsContinuous, } from "../util";
import { FalconArray } from "../falconArray";
export class View1D extends ViewAbstract {
    constructor(falcon, dimension) {
        super(falcon);
        this.dimension = dimension;
        this.state = { total: null, filter: null, bin: null };
        this.toPixels = () => [0, 0];
    }
    /**
     * slowest way to update data
     *
     * @todo this breaks when an active view is on
     * @todo replace this with targeted updates instead of just recomputing everything
     */
    async update(dimension) {
        this.dimension = dimension;
        await this.falcon.link();
    }
    /**
     * populates the extent in the dimension if not already defined
     *
     * @note that when the user does provide a binConfig, that will replace the range
     */
    async createBins() {
        // no matter if the dimension is continuous or categorical, compute the range (possible values)
        if (this.dimension?.range === undefined) {
            this.dimension.range = await this.falcon.db.range(this.dimension);
        }
        // for continuous, we need to compute the bin config
        if (this.dimension.type === "continuous") {
            const userProvidedCustomBinConfig = this.dimension.binConfig !== undefined;
            if (userProvidedCustomBinConfig) {
                this.dimension.range = [
                    this.dimension.binConfig.start,
                    this.dimension.binConfig.stop,
                ];
            }
            else if (!userProvidedCustomBinConfig) {
                // if the bins are specified, autocompute the best num of bins!
                // then create the bin config
                this.dimension.bins =
                    this.dimension.bins ??
                        (await this.falcon.db.estimateNumBins(this.dimension, 200, 15));
                this.dimension.binConfig = createBinConfigContinuous(this.dimension, this.dimension.range, this.dimension.exact ?? false);
            }
            else {
                throw Error("Invalid bin config or bins not specified");
            }
            const { start: firstBinStart, stop: veryLastBinEnd } = this.dimension.binConfig;
            this.toPixels = brushToPixelSpace([firstBinStart, veryLastBinEnd], this.dimension.resolution);
        }
        // when I give the user values, give them a prettier version of the range
        if (this.dimension.type === "continuous") {
            // save the bin definitions
            /**
             * @todo consider changing the format and only given them bin starts with binEnd implicit
             */
            this.state.bin = binStartBinEndArray(this.dimension.binConfig);
        }
        else {
            // the regular string array format with names is already readable
            this.state.bin = this.dimension.range;
        }
    }
    /**
     *  initializes the counts for the view over the entire data
     *
     * @returns the View1D class itself
     */
    async all() {
        await this.createBins();
        const counts = await this.falcon.db.histogramView1D(this, this.falcon.filters.size > 0 ? this.falcon.otherFilters(this) : undefined);
        this.state.total = counts.noFilter.data;
        this.state.filter = counts.filter.data;
        this.signalOnChange(this.state);
        return this;
    }
    /**
     * prefetch the 1D falcon index
     */
    async computeIndex(force = false) {
        if (!this.isActive || force) {
            // make sure we have binConfigs computed for all views if this one is activated
            await this.falcon.views.forEach(async (view) => {
                const rangeNotComputed = view instanceof View1D &&
                    (!("range" in view.dimension) ||
                        (view.dimension.type === "continuous" &&
                            !("binConfig" in view.dimension)));
                // we just count the whole shebang too
                if (rangeNotComputed) {
                    await view.all();
                }
            });
            // make the current one active and rest passive
            this.markThisViewActive();
            // fetch the index
            // and store globally
            this.falcon.index = this.falcon.db.falconIndexView1D(this, this.falcon.views.passive, this.falcon.passiveFilters);
        }
    }
    /**
     * activates this view: makes this view the active view
     *
     * this prefetches the falcon index under the hood that does all the speedups
     */
    async activate() {
        await this.computeIndex();
    }
    /**
     * compute counts from the falcon index
     */
    async select(filter, force = false) {
        if (filter) {
            if (this.dimension.type === "continuous") {
                // just end now if the filter hasn't changed
                const filterStayedTheSame = this.lastFilter &&
                    this.lastFilter[0] === filter[0] &&
                    this.lastFilter[1] === filter[1];
                if (filterStayedTheSame && force === false) {
                    return;
                }
                // add filter
                this.falcon.filters.set(this.dimension, filter);
                // convert active selection into pixels if needed
                let selectPixels = this.toPixels(filter);
                if (this.isActive) {
                    // use the index to count for the passive views
                    this.falcon.views.passive.forEach(async (passiveView) => {
                        await passiveView.countFromActiveContinuous1D(selectPixels);
                    });
                }
                this.lastFilter = filter;
            }
            else {
                // add filter
                this.falcon.filters.set(this.dimension, filter);
                if (this.isActive) {
                    // use the index to count for the passive views
                    this.falcon.views.passive.forEach(async (passiveView) => {
                        await passiveView.countFromActiveCategorical1D(filter, this.dimension.range);
                    });
                }
                this.lastFilter = filter;
            }
        }
        else {
            if (this.isActive) {
                if (this.dimension.type === "continuous") {
                    // just end now if the filter hasn't changed (still undefined)
                    const filterStayedTheSame = this.lastFilter === filter;
                    if (filterStayedTheSame) {
                        return;
                    }
                    // remove filter
                    this.falcon.filters.delete(this.dimension);
                    // and revert back counts
                    this.falcon.views.passive.forEach(async (passiveView) => {
                        await passiveView.countFromActiveContinuous1D();
                    });
                    this.lastFilter = filter;
                }
                else {
                    // remove filter
                    this.falcon.filters.delete(this.dimension);
                    // and revert back counts
                    this.falcon.views.passive.forEach(async (passiveView) => {
                        await passiveView.countFromActiveCategorical1D();
                    });
                    this.lastFilter = filter;
                }
            }
        }
    }
    /**
     * Given an active 1D view, count for this passive view
     */
    async countFromActiveContinuous1D(pixels) {
        // grab index
        const index = await this.falcon.index.get(this);
        if (index === undefined) {
            throw Error("Index not defined for 1D passive view");
        }
        // update state
        if (!pixels) {
            this.state.filter = index.noFilter.data;
        }
        else {
            // select the columns and subtract them to get in between [A, B]
            const A = index.filter.slice(pixels[0], null);
            const B = index.filter.slice(pixels[1], null);
            const binCounts = B.sub(A);
            this.state.filter = binCounts.data;
        }
        // signal user
        this.signalOnChange(this.state);
    }
    /**
     * Given an active 1D view, count for this passive view
     */
    async countFromActiveCategorical1D(selection, totalRange) {
        // grab index
        const index = await this.falcon.index.get(this);
        if (index === undefined) {
            throw Error("Index not defined for 1D passive view");
        }
        // update state
        if (!selection) {
            this.state.filter = index.noFilter.data;
        }
        else {
            let binCounts;
            if (this.dimension.type === "continuous") {
                binCounts = FalconArray.allocCounts(numBinsContinuous(this.dimension.binConfig));
            }
            else {
                binCounts = FalconArray.allocCounts(this.dimension.range.length);
            }
            binCounts.data.fill(0);
            const bin = binNumberFunctionCategorical(totalRange);
            for (const s of selection) {
                const binKey = bin(s);
                if (binKey !== undefined) {
                    const counts = index.filter.slice(binKey, null);
                    binCounts.addToItself(counts);
                }
            }
            this.state.filter = binCounts.data;
        }
        // signal user
        this.signalOnChange(this.state);
    }
    /**
     * attaches to the global falcon index
     */
    async attach() {
        this.falcon.views.add(this);
        await this.falcon.link();
    }
    /**
     * detaches from the global falcon index
     *
     * if I detach an active view, I need to relink
     */
    async detach() {
        this.falcon.views.remove(this);
        this.falcon.index.delete(this);
        // if we remove the active view, revert back
        if (this.isActive) {
            await this.falcon.link();
        }
    }
}
//# sourceMappingURL=view1D.js.map
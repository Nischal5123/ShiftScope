import type { CategoricalRange, ContinuousDimension } from "./dimension";
/**
 * UTILITY TYPES
 * -------------
 */
export type Interval<T> = [T, T];
export type BinNumberFunction = (key: any) => number | undefined;
/**
 * Binning configuration.
 */
export interface BinConfig {
    start: number;
    stop: number;
    step: number;
}
/**
 * BinConfig that does not need to have a stop.
 */
/**
 * BinConfig that does not need to have a step.
 */
interface StartStopBinConfig {
    start: number;
    stop: number;
    step?: number;
}
/**
 * UTILITY FUNCTIONS
 * -----------------
 */
/**
 * Get the number of bins for a bin configuration.
 */
export declare function numBinsCategorical(range: CategoricalRange): number;
/**
 * Takes the categorical names and maps them to indices
 * @returns function that returns bin index
 */
export declare function binNumberFunctionCategorical(range: CategoricalRange): (item: any) => number | undefined;
/**
 * Get the number of bins for a bin configuration.
 */
export declare function numBinsContinuous({ start, step, stop }: BinConfig): number;
export declare function binContinuous(maxbins: number, extent: Interval<number>, exact?: boolean): BinConfig;
export declare function binTime(maxbins: number, extent: Interval<number>, exact?: boolean): BinConfig;
/**
 * This function requires dimension.bins to exist
 *
 * if the exactNumberOfBins is true, will force a regular interval
 * if not, will try to make the bins as nice as possible, but maybe different number of bins than requested
 */
export declare function createBinConfigContinuous(dimension: ContinuousDimension, extent: Interval<number>, exactNumberOfBins?: boolean): BinConfig;
export declare function binStartBinEndArray(binConfig: BinConfig): {
    binStart: number;
    binEnd: number;
}[];
export declare function conciseBinsContinuous(binConfig: BinConfig): Float32Array;
/**
 * returns a function to scales to pixel resolution to
 * the floor integer pixel
 */
export declare function brushToPixelSpace(extent: Interval<number>, resolution: number): (brush: Interval<number>) => Interval<number>;
/**
 * returns a function to scales to pixel resolution to
 * the floor integer pixel
 */
export declare function scaleFilterToResolution(extent: Interval<number>, resolution: number, nearestPixelInt?: (x: number) => number): (x: number) => number;
export declare function excludeMap<K, V>(map: Map<K, V>, ...exclude: K[]): Map<K, V>;
/**
 * Returns a function that returns the bin for a value.
 */
export declare function binNumberFunctionContinuous({ start, step, stop }: BinConfig): (v: number) => number;
/**
 * Creates a string equivalent to binNumberFunctionContinuous operation in SQL
 */
export declare function binNumberFunctionContinuousSQL(field: string, { start, step, stop }: BinConfig, castString?: (x: number) => string, caseVersion?: boolean): string;
/**
 * Returns a function that returns the bin for a pixel. Starts one pixel before so that the brush contains the data.
 */
export declare function binNumberFunctionPixels({ start, stop }: StartStopBinConfig, pixel: number): (v: number) => number;
export declare function stepSize({ start, stop }: StartStopBinConfig, bins: number): number;
export declare function compactQuery(str: string): string;
export {};

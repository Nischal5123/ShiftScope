<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test JavaScript</title>
</head>
<body>
    <script>
        // Paste the JavaScript block here
        const algorithm_predictions = {
            'RL': ['airport_name', 'aircraft_make_model', 'effect_amount_of_damage'],
            'Random': ['airport_name', 'aircraft_make_model', 'effect_amount_of_damage'],
            'Momentum': ['airport_name', 'aircraft_make_model', 'effect_amount_of_damage']
        };

        const user_selections = ['airport_name', 'aircraft_make_model', 'effect_amount_of_damage'];

        // Global variables to store history
const history_accuracy = {'RL': [], 'Random': [], 'Momentum': []};
const history_user_selection_corresponding_prediction = [];

// Function to create the accuracy chart
function createAccuracyChart(id, algorithm_predictions, user_selections) {
    const margin = { top: 20, right: 50, bottom: 50, left: 190 };
    const width = Math.max(window.innerWidth * 0.8 - margin.left - margin.right, 300);
    const height = window.innerHeight * 0.6 - margin.top - margin.bottom;

    // Clear the existing SVG content
    d3.select(`#${id}`).selectAll("*").remove();

    var svg = d3.select(`#${id}`).append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    const timeLabels = Object.keys(algorithm_predictions);
    const time = timeLabels.length;

    var xScale = d3.scaleBand()
        .domain(timeLabels)
        .range([0, width])
        .padding(0.1);

    var yScale = d3.scaleLinear()
        .domain([0, 1.1])
        .range([height, 0]);

    var colors = d3.scaleOrdinal()
        .domain(Object.keys(algorithm_predictions))
        .range(d3.schemeCategory10);

    // Draw lines for each dataset
    Object.entries(algorithm_predictions).forEach(([algorithm, prediction]) => {
        const accuracy = calculateAccuracy(prediction, user_selections);
        history_accuracy[algorithm].push(accuracy); // Store accuracy in history

        // Draw line
        svg.append("path")
            .datum(accuracy)
            .attr("fill", "none")
            .attr("stroke", colors(algorithm))
            .attr("stroke-width", 2)
            .attr("d", line)
            .on("click", function(_, i) {
                updateTimeSeriesChart(i);
            });

        // Add labels for different algorithms
        svg.append("text")
            .attr("x", width - 35)
            .attr("y", margin.top + 20 * i)
            .attr("fill", colors(algorithm))
            .text(algorithm);
    });

    // Add circles to represent data points
    // Implementation depends on how you want to represent individual data points

    // Add x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(xScale));

    // Add y-axis
    svg.append("g")
        .call(d3.axisLeft(yScale).ticks(5));

    // Add x-axis label
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", height + margin.bottom - 10)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .text("Recommendation Cycle");

    // Add y-axis label
    svg.append("text")
        .attr("transform", `translate(-35, ${height / 2}) rotate(-90)`)
        .attr("text-anchor", "middle")
        .style("font-size", "14px")
        .text("Hit Rate");

    // Brush functionality
    svg.append("g").call(d3.brushX()
        .extent([[0, 0], [width, height]])
        .on("end", brushChart));

    function brushChart() {
        var selection = d3.event.selection;
        if (selection) {
            var selectedTimes = [];
            var startIndex = Math.round(selection[0] / (xScale.bandwidth() + xScale.step()));
            var endIndex = Math.round(selection[1] / (xScale.bandwidth() + xScale.step()));
            for (var i = startIndex; i <= endIndex; i++) {
                selectedTimes.push(i);
            }
            updateTimeSeriesChart(selectedTimes);
        }
    }
}

    // Function to calculate accuracy
    function calculateAccuracy(prediction, user_selections) {
        // Placeholder implementation - calculate accuracy based on prediction and user selections
        return Math.random(); // Replace this with actual calculation
    }

    // Function to update the time series chart
    function updateTimeSeriesChart(clickedTime) {
        // Placeholder function - Implement logic to update time series chart here
        console.log("Updating time series chart for time:", clickedTime);
    }


        }
    </script>
</body>
</html>
